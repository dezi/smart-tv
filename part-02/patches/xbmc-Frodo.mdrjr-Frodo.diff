diff --git a/configure.in b/configure.in
index e98cc95..ab1ab62 100644
--- a/configure.in
+++ b/configure.in
@@ -157,6 +157,10 @@ libusb_disabled="== libusb disabled. Plug and play USB device support will not b
 libusb_disabled_udev_found="== libusb disabled. =="
 libcec_enabled="== libcec enabled. =="
 libcec_disabled="== libcec disabled. CEC adapter support will not be available. =="
+exynos4_enabled="== Exynos4 enabled. =="
+exynos4_disabled="== Exynos4 disabled. =="
+exynos5_enabled="== Exynos4 enabled. =="
+exynos5_disabled="== Exynos4 disabled. =="
 
 # External library message strings
 external_libraries_enabled="== Use of all supported external libraries enabled. =="
@@ -518,6 +522,18 @@ AC_ARG_ENABLE([external-ffmpeg],
   [use_external_ffmpeg=$enableval],
   [use_external_ffmpeg=$use_external_libraries])
 
+AC_ARG_ENABLE([exynos4],
+  [AS_HELP_STRING([--enable-exynos4],
+  [enable use of Exynos4 hardware decoder (default is no) 'Linux only'])],
+  [use_exynos4=$enableval],
+  [use_exynos4=no])
+
+AC_ARG_ENABLE([exynos5],
+  [AS_HELP_STRING([--enable-exynos5],
+  [enable use of Exynos5 hardware decoder (default is no) 'Linux only'])],
+  [use_exynos5=$enableval],
+  [use_exynos5=no])
+
 ### End of external library options
 
 if test "x$host_vendor" != "xapple"; then
@@ -1483,6 +1499,16 @@ else
   AC_MSG_NOTICE($libcec_disabled)
 fi
 
+USE_EXYNOS4=0
+if test "x$use_exynos4" != "xno"; then
+  USE_EXYNOS4=1;AC_DEFINE(HAVE_EXYNOS4,[1],["Define if Exynos4 platform hardware decoder is present"])
+fi
+
+USE_EXYNOS5=0
+if test "x$use_exynos5" != "xno"; then
+  USE_EXYNOS5=1;AC_DEFINE(HAVE_EXYNOS5,[1],["Define if Exynos5 platform hardware decoder is present"])
+fi
+
 # libcap
 if test "$use_libcap" != "no"; then
   AC_CHECK_HEADERS([sys/capability.h],,
@@ -2235,6 +2261,18 @@ else
   final_message="$final_message\n  libcec support:\tNo"
 fi
 
+if test "x$use_exynos4" != "xno"; then
+  final_message="$final_message\n  Exynos4 support:\tYes"
+else
+  final_message="$final_message\n  Exynos4 support:\tNo"
+fi
+
+if test "x$use_exynos5" != "xno"; then
+  final_message="$final_message\n  Exynos5 support:\tYes"
+else
+  final_message="$final_message\n  Exynos5 support:\tNo"
+fi
+
 if test "x$use_libmp3lame" != "xno"; then
   final_message="$final_message\n  libmp3lame support:\tYes"
 else
@@ -2430,6 +2468,8 @@ AC_SUBST(USE_ANDROID)
 AC_SUBST(GTEST_CONFIGURED)
 AC_SUBST(USE_DOXYGEN)
 AC_SUBST(USE_PVR_ADDONS)
+AC_SUBST(USE_EXYNOS4)
+AC_SUBST(USE_EXYNOS5)
 
 # pushd and popd are not available in other shells besides bash, so implement
 # our own pushd/popd functions
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index cb0939f..032ec74 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -525,6 +525,7 @@ unsigned int CLinuxRendererGLES::PreInit()
   m_NumYV12Buffers = 2;
 
   m_formats.push_back(RENDER_FMT_YUV420P);
+  m_formats.push_back(RENDER_FMT_NV12MT);
   m_formats.push_back(RENDER_FMT_BYPASS);
 #if defined(HAVE_LIBOPENMAX)
   m_formats.push_back(RENDER_FMT_OMXEGL);
diff --git a/xbmc/cores/VideoRenderers/RenderFormats.h b/xbmc/cores/VideoRenderers/RenderFormats.h
index 09f8f5d..84bcf62 100644
--- a/xbmc/cores/VideoRenderers/RenderFormats.h
+++ b/xbmc/cores/VideoRenderers/RenderFormats.h
@@ -27,6 +27,7 @@ enum ERenderFormat {
   RENDER_FMT_YUV420P16,
   RENDER_FMT_VDPAU,
   RENDER_FMT_NV12,
+  RENDER_FMT_NV12MT,
   RENDER_FMT_UYVY422,
   RENDER_FMT_YUYV422,
   RENDER_FMT_DXVA,
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index d22287d..a9c94a4 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -819,6 +819,10 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
   {
     CDVDCodecUtils::CopyNV12Picture(&image, &pic);
   }
+  else if(pic.format == RENDER_FMT_NV12MT)
+  {
+    CDVDCodecUtils::CopyNV12MTPicture(&image, &pic);
+  }
   else if(pic.format == RENDER_FMT_YUYV422
        || pic.format == RENDER_FMT_UYVY422)
   {
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp
index 77e4277..f0e606b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp
@@ -25,6 +25,11 @@
 #include "utils/fastmemcpy.h"
 #include "DllSwScale.h"
 
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CDVDCodecUtils"
+
 // allocate a new picture (PIX_FMT_YUV420P)
 DVDVideoPicture* CDVDCodecUtils::AllocatePicture(int iWidth, int iHeight)
 {
@@ -346,6 +351,181 @@ bool CDVDCodecUtils::CopyYUV422PackedPicture(YV12Image* pImage, DVDVideoPicture
   return true;
 }
 
+bool CDVDCodecUtils::CopyNV12MTPicture(YV12Image* pImage, DVDVideoPicture *pSrc)
+{
+#define NV12MT_HALIGN 64
+#define NV12MT_VALIGN 32
+#define INT_ROUND(x, y) ((x % y) > 0 ? (int(x/y)+1) : (int(x/y)) )
+
+  unsigned int time = XbmcThreads::SystemClockMillis();
+  
+  BYTE *s = pSrc->data[0];
+  BYTE *d = pImage->plane[0];
+  int w = INT_ROUND(pSrc->iWidth, 128) * 128;
+  int h = INT_ROUND(pSrc->iHeight, 32) * 32;
+
+  int b;
+  BYTE *s_offset, *d_offset;
+  int dbx, dby;
+  int num_bytes, num_lines;
+  int nb_xb = INT_ROUND(w, NV12MT_HALIGN);
+  int nb_yb = INT_ROUND(h, NV12MT_VALIGN);
+  int nb_xmb = nb_xb / 2;
+  int nb_ymb = nb_yb / 2;
+
+  printf("NV12MT Y: nb_xb:%d nb_yb:%d \n", nb_xb, nb_yb);
+  
+  // Copy Y
+  int ymb=0;
+  for (; ymb<nb_ymb; ymb++)
+  {
+    bool zed = true;
+
+    for (int xmb=0; xmb<nb_xmb; xmb++)
+    {
+      for (int yb=0; yb<2; yb++)
+      {
+        dby = (ymb*2) + yb;
+        num_lines = ((dby+1)*NV12MT_VALIGN) < pSrc->iHeight ? NV12MT_VALIGN : pSrc->iHeight - (dby*NV12MT_VALIGN);
+
+        for (int xb=0; xb<2; xb++)
+        {
+          b = (ymb*2*nb_xb) + (xmb*4) + (zed ? (yb*2) : ((1-yb)*2)) + xb;
+          s_offset = s + (b * NV12MT_HALIGN * NV12MT_VALIGN);
+          dbx = (xmb*2) + xb;
+          d_offset = d + (dby*NV12MT_VALIGN * pImage->stride[0]) + (dbx*NV12MT_HALIGN);
+          num_bytes = ((dbx+1)*NV12MT_HALIGN) < pSrc->iWidth ? NV12MT_HALIGN : pSrc->iWidth - (dbx*NV12MT_HALIGN);
+          // printf("NV12MT: b:%d dbx:%d dby:%d s_offset:%d d_offset:%d\n", b, dbx, dby, s_offset, d_offset);
+
+          for (int y=0; y<num_lines; y++)
+          {
+            fast_memcpy(d_offset, s_offset, num_bytes);
+            s_offset += NV12MT_HALIGN;
+            d_offset += pImage->stride[0];
+          }
+        }
+      }
+
+      zed = !zed;
+    }
+  }
+  if (ymb*2 < nb_yb)
+  {
+      dby = nb_yb-1;
+      num_lines = ((dby+1)*NV12MT_VALIGN) < pSrc->iHeight ? NV12MT_VALIGN : pSrc->iHeight - (dby*NV12MT_VALIGN);
+
+      for (int xb=0; xb<nb_xb; xb++)
+      {
+          b = ((nb_yb-1)*nb_xb) + xb;
+          s_offset = s + (b * NV12MT_HALIGN * NV12MT_VALIGN);
+          dbx = xb;
+          d_offset = d + (dby*NV12MT_VALIGN * pImage->stride[0]) + (dbx*NV12MT_HALIGN);
+          num_bytes = ((dbx+1)*NV12MT_HALIGN) < pSrc->iWidth ? NV12MT_HALIGN : pSrc->iWidth - (dbx*NV12MT_HALIGN);
+          // printf("NV12MT: b:%d dbx:%d dby:%d s_offset:%d d_offset:%d\n", b, dbx, dby, s_offset, d_offset);
+
+          for (int y=0; y<num_lines; y++)
+          {
+              fast_memcpy(d_offset, s_offset, num_bytes);
+              s_offset += NV12MT_HALIGN;
+              d_offset += pImage->stride[0];
+          }
+      }
+  }
+
+  unsigned int ytime = XbmcThreads::SystemClockMillis() - time;
+  
+  s = pSrc->data[1];
+  BYTE* du = pImage->plane[1];
+  BYTE* dv = pImage->plane[2];
+  w = INT_ROUND(pSrc->iWidth, 128) * 128;
+  h = INT_ROUND(pSrc->iHeight / 2, 32) * 32;
+
+  nb_xb = INT_ROUND(w, NV12MT_HALIGN);
+  nb_yb = INT_ROUND(h, NV12MT_VALIGN);
+  nb_xmb = nb_xb / 2;
+  nb_ymb = nb_yb / 2;
+
+  printf("NV12MT UV: nb_xb:%d nb_yb:%d \n", nb_xb, nb_yb);
+  
+  BYTE *du_offset, *dv_offset;
+  int doff;
+
+  // Copy packed UV (width is same as for Y as it's both U and V components)
+  ymb=0;
+  for (; ymb<nb_ymb; ymb++)
+  {
+    bool zed = true;
+
+    for (int xmb=0; xmb<nb_xmb; xmb++)
+    {
+      for (int yb=0; yb<2; yb++)
+      {
+        dby = (ymb*2) + yb;
+        num_lines = ((dby+1)*NV12MT_VALIGN) < (pSrc->iHeight>>1) ? NV12MT_VALIGN : (pSrc->iHeight>>1) - (dby*NV12MT_VALIGN);
+
+        for (int xb=0; xb<2; xb++)
+        {
+          b = (ymb*2*nb_xb) + (xmb*4) + (zed ? (yb*2) : ((1-yb)*2)) + xb;
+          s_offset = s + (b * NV12MT_HALIGN * NV12MT_VALIGN);
+          dbx = (xmb*2) + xb;
+          doff = (dby*NV12MT_VALIGN * pImage->stride[1]) + (dbx*NV12MT_HALIGN>>1);
+          du_offset = du + doff;
+          dv_offset = dv + doff;
+          num_bytes = ((dbx+1)*NV12MT_HALIGN) < pSrc->iWidth ? NV12MT_HALIGN : (pSrc->iWidth) - (dbx*NV12MT_HALIGN);
+          //printf("NV12MT: b:%d dbx:%d dby:%d s_offset:%d d_offset:%d num_lines:%d num_bytes:%d\n", b, dbx, dby, s_offset, d_offset, num_lines, num_bytes);
+
+          for (int y=0; y<num_lines; y++)
+          {
+            for (int x=0; x<num_bytes; x+=2)
+            {
+              *(du_offset + (x>>1)) = *(s_offset + x);
+              *(dv_offset + (x>>1)) = *(s_offset + x+1);
+            }
+            s_offset += NV12MT_HALIGN;
+            du_offset += pImage->stride[1];
+            dv_offset += pImage->stride[1];
+          }
+        }
+      }
+
+      zed = !zed;
+    }
+  }
+  if (ymb*2 < nb_yb)
+  {
+      dby = nb_yb-1;
+      num_lines = ((dby+1)*NV12MT_VALIGN) < (pSrc->iHeight>>1) ? NV12MT_VALIGN : (pSrc->iHeight>>1) - (dby*NV12MT_VALIGN);
+
+      for (int xb=0; xb<nb_xb; xb++)
+      {
+          b = ((nb_yb-1)*nb_xb) + xb;
+          s_offset = s + (b * NV12MT_HALIGN * NV12MT_VALIGN);
+          dbx = xb;
+          doff = (dby*NV12MT_VALIGN * pImage->stride[1]) + (dbx*NV12MT_HALIGN>>1);
+          du_offset = du + doff;
+          dv_offset = dv + doff;
+          num_bytes = ((dbx+1)*NV12MT_HALIGN) < pSrc->iWidth ? NV12MT_HALIGN : (pSrc->iWidth) - (dbx*NV12MT_HALIGN);
+          // printf("NV12MT: b:%d dbx:%d dby:%d s_offset:%d d_offset:%d\n", b, dbx, dby, s_offset, d_offset);
+
+          for (int y=0; y<num_lines; y++)
+          {
+              for (int x=0; x<num_bytes; x+=2)
+              {
+                *(du_offset + (x>>1)) = *(s_offset + x);
+                *(dv_offset + (x>>1)) = *(s_offset + x+1);
+              }
+              s_offset += NV12MT_HALIGN;
+              du_offset += pImage->stride[1];
+              dv_offset += pImage->stride[1];
+          }
+      }
+  }
+
+  printf("%s::%s NV12MT tm:%d/%d\n", CLASSNAME, __func__, ytime, XbmcThreads::SystemClockMillis() - time);
+  
+  return true;
+}
+
 bool CDVDCodecUtils::CopyDXVA2Picture(YV12Image* pImage, DVDVideoPicture *pSrc)
 {
 #ifdef HAS_DX
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.h b/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.h
index 99e16c4..d72958a 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.h
@@ -36,6 +36,7 @@ class CDVDCodecUtils
   static DVDVideoPicture* ConvertToNV12Picture(DVDVideoPicture *pSrc);
   static DVDVideoPicture* ConvertToYUV422PackedPicture(DVDVideoPicture *pSrc, ERenderFormat format);
   static bool CopyNV12Picture(YV12Image* pImage, DVDVideoPicture *pSrc);
+  static bool CopyNV12MTPicture(YV12Image* pImage, DVDVideoPicture *pSrc); 
   static bool CopyYUV422PackedPicture(YV12Image* pImage, DVDVideoPicture *pSrc);
   static bool CopyDXVA2Picture(YV12Image* pImage, DVDVideoPicture *pSrc);
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 0cea7a9..d60f714 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -30,6 +30,12 @@
 #if defined(HAVE_VIDEOTOOLBOXDECODER)
 #include "Video/DVDVideoCodecVideoToolBox.h"
 #endif
+#if defined(HAVE_EXYNOS4)
+#include "Video/DVDVideoCodecExynos4.h"
+#endif
+#if defined(HAVE_EXYNOS5)
+#include "Video/DVDVideoCodecExynos5.h"
+#endif
 #include "Video/DVDVideoCodecFFmpeg.h"
 #include "Video/DVDVideoCodecOpenMax.h"
 #include "Video/DVDVideoCodecLibMpeg2.h"
@@ -169,9 +175,26 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
 #elif defined(_LINUX) && !defined(TARGET_DARWIN)
   hwSupport += "VAAPI:no ";
 #endif
+#if defined(HAVE_EXYNOS4) && defined(_LINUX)
+  hwSupport += "MFCv5:yes";
+#elif defined(_LINUX)
+  hwSupport += "MFCv5:no";
+#endif
+#if defined(HAVE_EXYNOS5) && defined(_LINUX)
+  hwSupport += "MFCv6:yes";
+#elif defined(_LINUX)
+  hwSupport += "MFCv6:no";
+#endif
 
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
+#if defined(HAVE_EXYNOS4) && defined(_LINUX)
+  if( (pCodec = OpenCodec(new CDVDVideoCodecExynos4(), hint, options)) ) return pCodec;
+#endif
+#if defined(HAVE_EXYNOS5) && defined(_LINUX)
+  if( (pCodec = OpenCodec(new CDVDVideoCodecExynos5(), hint, options)) ) return pCodec;
+#endif
+
   // dvd's have weird still-frames in it, which is not fully supported in ffmpeg
   if(hint.stills && (hint.codec == CODEC_ID_MPEG2VIDEO || hint.codec == CODEC_ID_MPEG1VIDEO))
   {
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index 1d8bad3..aaa4336 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -38,6 +38,7 @@
 class COpenMax;
 class COpenMaxVideo;
 struct OpenMaxVideoBuffer;
+struct V4L2Buffer;
 
 // should be entirely filled by all codecs
 struct DVDVideoPicture
@@ -69,6 +70,11 @@ struct DVDVideoPicture
     struct {
       struct __CVBuffer *cvBufferRef;
     };
+
+    struct {
+      V4L2Buffer *mfcBuffer;
+    }; 
+
   };
 
   unsigned int iFlags;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecExynos4.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecExynos4.cpp
new file mode 100644
index 0000000..d1cb67d
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecExynos4.cpp
@@ -0,0 +1,786 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#if (defined HAVE_CONFIG_H) && (!defined WIN32)
+  #include "config.h"
+#endif
+#include "DVDVideoCodecExynos4.h"
+#include "DVDDemuxers/DVDDemux.h"
+#include "DVDStreamInfo.h"
+#include "DVDClock.h"
+#include "DVDCodecs/DVDCodecs.h"
+#include "DVDCodecs/DVDCodecUtils.h"
+
+#define MAJOR_VERSION 12
+
+#include "settings/Settings.h"
+#if MAJOR_VERSION < 13
+	#include "settings/GUISettings.h"
+#else
+	#include "settings/DisplaySettings.h"
+	#include "settings/AdvancedSettings.h"
+#endif
+#include "utils/fastmemcpy.h"
+
+#include <linux/LinuxV4l2.h>
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <dirent.h>
+
+#define USE_FIMC 1 //doesn't work now, do not undefine!
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CDVDVideoCodecExynos4"
+
+CDVDVideoCodecExynos4::CDVDVideoCodecExynos4() : CDVDVideoCodec() {
+  m_v4l2MFCOutputBuffers = NULL;
+  m_v4l2MFCCaptureBuffers = NULL;
+  m_v4l2FIMCCaptureBuffers = NULL;
+
+  m_MFCOutputBuffersCount = 0;
+  m_MFCCaptureBuffersCount = 0;
+  m_FIMCOutputBuffersCount = 0;
+  m_FIMCCaptureBuffersCount = 0;
+
+  m_iMFCCapturePlane1Size = -1;
+  m_iMFCCapturePlane2Size = -1;
+  m_iFIMCCapturePlane1Size = -1;
+  m_iFIMCCapturePlane2Size = -1;
+  m_iFIMCCapturePlane3Size = -1;
+
+  m_iDecodedWidth = 0;
+  m_iDecodedHeight = 0;
+  m_iConvertedWidth = 0;
+  m_iConvertedHeight = 0;
+  m_iDecoderHandle = -1;
+  m_iConverterHandle = -1;
+  m_bVideoConvert = false;
+  m_bDropPictures = false;
+  
+  m_bFIMCStartConverter = true;
+  
+  m_iFIMCdequeuedBufferNumber = -1;
+  
+  memzero(m_videoBuffer);
+}
+
+CDVDVideoCodecExynos4::~CDVDVideoCodecExynos4() {
+  Dispose();
+}
+
+bool CDVDVideoCodecExynos4::OpenDevices() {
+  DIR *dir;
+  struct dirent *ent;
+
+  if ((dir = opendir ("/sys/class/video4linux/")) != NULL) {
+    while ((ent = readdir (dir)) != NULL) {
+      if (strncmp(ent->d_name, "video", 5) == 0) {
+        char *p;
+        char name[64];
+        char devname[64];
+        char sysname[64];
+        char drivername[32];
+        char target[1024];
+        int ret;
+
+        snprintf(sysname, 64, "/sys/class/video4linux/%s", ent->d_name);
+        snprintf(name, 64, "/sys/class/video4linux/%s/name", ent->d_name);
+
+        FILE* fp = fopen(name, "r");
+        if (fgets(drivername, 32, fp) != NULL) {
+          p = strchr(drivername, '\n');
+          if (p != NULL)
+            *p = '\0';
+        } else {
+          fclose(fp);
+          continue;
+        }
+        fclose(fp);
+
+        ret = readlink(sysname, target, sizeof(target));
+        if (ret < 0)
+          continue;
+        target[ret] = '\0';
+        p = strrchr(target, '/');
+        if (p == NULL)
+          continue;
+
+        sprintf(devname, "/dev/%s", ++p);
+
+        if (m_iDecoderHandle < 0 && strncmp(drivername, "s5p-mfc-dec", 11) == 0) {
+          struct v4l2_capability cap;
+          int fd = open(devname, O_RDWR | O_NONBLOCK, 0);
+          if (fd > 0) {
+            memzero(cap);
+            ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);
+            if (ret == 0)
+              if ((cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
+                ((cap.capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE) && (cap.capabilities & V4L2_CAP_VIDEO_OUTPUT_MPLANE))) &&
+                (cap.capabilities & V4L2_CAP_STREAMING)) {
+                m_iDecoderHandle = fd;
+                CLog::Log(LOGDEBUG, "%s::%s - Found %s %s", CLASSNAME, __func__, drivername, devname);
+              }
+          }
+          if (m_iDecoderHandle < 0)
+            close(fd);
+        }
+        if (m_iConverterHandle < 0 && strstr(drivername, "fimc") != NULL && strstr(drivername, "m2m") != NULL) {
+          struct v4l2_capability cap;
+          int fd = open(devname, O_RDWR, 0);
+          if (fd > 0) {
+            memzero(cap);
+            ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);
+            if (ret == 0)
+              if ((cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
+                ((cap.capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE) && (cap.capabilities & V4L2_CAP_VIDEO_OUTPUT_MPLANE))) &&
+                (cap.capabilities & V4L2_CAP_STREAMING)) {
+                m_iConverterHandle = fd;
+                CLog::Log(LOGDEBUG, "%s::%s - Found %s %s", CLASSNAME, __func__, drivername, devname);
+              }
+          }
+          if (m_iConverterHandle < 0)
+            close(fd);
+        }
+        if (m_iDecoderHandle >= 0 && m_iConverterHandle >= 0)
+          return true;
+      }
+    }
+    closedir (dir);
+  }
+  return false;
+}
+
+bool CDVDVideoCodecExynos4::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) {
+  struct v4l2_format fmt;
+  struct v4l2_control ctrl;
+  struct v4l2_crop crop;
+  int ret = 0;
+
+  if (hints.software)
+    return false;
+
+  Dispose();
+
+  if (!OpenDevices()) {
+    CLog::Log(LOGDEBUG, "%s::%s - Needed devices not found", CLASSNAME, __func__);
+    return false;
+  }
+
+  m_bVideoConvert = m_converter.Open(hints.codec, (uint8_t *)hints.extradata, hints.extrasize, true);
+
+  unsigned int extraSize = 0;
+  uint8_t *extraData = NULL;
+
+  if(m_bVideoConvert) {
+    if(m_converter.GetExtraData() != NULL && m_converter.GetExtraSize() > 0) {
+      extraSize = m_converter.GetExtraSize();
+      extraData = m_converter.GetExtraData();
+    }
+  } else {
+    if(hints.extrasize > 0 && hints.extradata != NULL) {
+      extraSize = hints.extrasize;
+      extraData = (uint8_t*)hints.extradata;
+    }
+  }
+  
+  // Setup mfc output queue (OUTPUT - name of the queue where TO encoded frames are streamed, CAPTURE - name of the queue where FROM decoded frames are taken)
+  // Set mfc output format
+  memzero(fmt);
+  switch(hints.codec)
+  {
+/*
+    case CODEC_TYPE_VC1_RCV:
+      return V4L2_PIX_FMT_VC1_ANNEX_L;
+*/
+    case CODEC_ID_VC1:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_G;
+      m_name = "mfc-vc1";
+      break;
+    case CODEC_ID_MPEG1VIDEO:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG1;
+      m_name = "mfc-mpeg1";
+      break;
+    case CODEC_ID_MPEG2VIDEO:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG2;
+      m_name = "mfc-mpeg2";
+      break;
+    case CODEC_ID_MPEG4:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG4;
+      m_name = "mfc-mpeg4";
+      break;
+    case CODEC_ID_H263:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H263;
+      m_name = "mfc-h263";
+      break;
+    case CODEC_ID_H264:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H264;
+      m_name = "mfc-h264";
+      break;
+    default:
+      return false;
+      break;
+  }
+  fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+  fmt.fmt.pix_mp.plane_fmt[0].sizeimage = STREAM_BUFFER_SIZE;
+  fmt.fmt.pix_mp.num_planes = V4L2_NUM_MAX_PLANES;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_S_FMT, &fmt);
+  if (ret != 0) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT S_FMT failed", CLASSNAME, __func__);
+    return false;
+  }
+/* Debug call, unneded for production
+  // Get mfc output format
+  memzero(fmt);
+  fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_G_FMT, &fmt);
+  if (ret != 0) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT G_FMT failed", CLASSNAME, __func__);
+    return false;
+  }
+  msg("\e[1;32mMFC OUTPUT\e[0m Setup MFC decoding buffer size=%u (requested=%u)", CLASSNAME, __func__, fmt.fmt.pix_mp.plane_fmt[0].sizeimage, STREAM_BUFFER_SIZE);
+*/  
+  // Request mfc output buffers
+  m_MFCOutputBuffersCount = CLinuxV4l2::RequestBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, MFC_OUTPUT_BUFFERS_CNT);
+  if (m_MFCOutputBuffersCount == V4L2_ERROR) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT REQBUFS failed", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT REQBUFS Number of MFC buffers is %d (requested %d)", CLASSNAME, __func__, m_MFCOutputBuffersCount, MFC_OUTPUT_BUFFERS_CNT);
+
+  // Memory Map mfc output buffers
+  m_v4l2MFCOutputBuffers = (V4L2Buffer *)calloc(m_MFCOutputBuffersCount, sizeof(V4L2Buffer));
+  if(!m_v4l2MFCOutputBuffers) {
+    CLog::Log(LOGERROR, "%s::%s - MFC cannot allocate OUTPUT buffers in memory", CLASSNAME, __func__);
+    return false;
+  }
+  if(!CLinuxV4l2::MmapBuffers(m_iDecoderHandle, m_MFCOutputBuffersCount, m_v4l2MFCOutputBuffers, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, false)) {
+    CLog::Log(LOGERROR, "%s::%s - MFC Cannot mmap OUTPUT buffers", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT Succesfully mmapped %d buffers", CLASSNAME, __func__, m_MFCOutputBuffersCount);
+
+  // Prepare header
+  m_v4l2MFCOutputBuffers[0].iBytesUsed[0] = extraSize;
+  fast_memcpy((uint8_t *)m_v4l2MFCOutputBuffers[0].cPlane[0], extraData, extraSize);
+
+  // Queue header to mfc output queue
+  ret = CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, m_v4l2MFCOutputBuffers[0].iNumPlanes, 0, &m_v4l2MFCOutputBuffers[0]);
+  if (ret == V4L2_ERROR) {
+    CLog::Log(LOGERROR, "%s::%s - MFC Error queuing header", CLASSNAME, __func__);
+    return false;
+  }
+  m_v4l2MFCOutputBuffers[ret].bQueue = true;
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT <- %d header of size %d", CLASSNAME, __func__, ret, extraSize);
+
+  // STREAMON on mfc OUTPUT
+  if (!CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMON)) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT Failed to Stream ON", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT Stream ON", CLASSNAME, __func__);
+
+  // Setup mfc capture queue
+  // Get mfc capture picture format
+  memzero(fmt);
+  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_G_FMT, &fmt);
+  if (ret) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE G_FMT Failed", CLASSNAME, __func__);
+    return false;
+  }
+  m_iMFCCapturePlane1Size = fmt.fmt.pix_mp.plane_fmt[0].sizeimage;
+  m_iMFCCapturePlane2Size = fmt.fmt.pix_mp.plane_fmt[1].sizeimage;
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE G_FMT: fmt (%dx%d), plane[0]=%d plane[1]=%d", CLASSNAME, __func__, fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height, m_iMFCCapturePlane1Size, m_iMFCCapturePlane2Size);
+
+#ifdef USE_FIMC
+  // Setup FIMC OUTPUT fmt with data from MFC CAPTURE received on previous step
+  fmt.type                                = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+  fmt.fmt.pix_mp.field                    = V4L2_FIELD_ANY;
+  fmt.fmt.pix_mp.pixelformat              = V4L2_PIX_FMT_NV12MT;
+  fmt.fmt.pix_mp.num_planes               = V4L2_NUM_MAX_PLANES;
+  ret = ioctl(m_iConverterHandle, VIDIOC_S_FMT, &fmt);
+  if (ret != 0) {
+    CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT S_FMT Failed", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT S_FMT (%dx%d)", CLASSNAME, __func__, fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height);
+#endif
+
+  // Get mfc needed number of buffers
+  memzero(ctrl);
+  ctrl.id = V4L2_CID_MIN_BUFFERS_FOR_CAPTURE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_G_CTRL, &ctrl);
+  if (ret) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Failed to get the number of buffers required", CLASSNAME, __func__);
+    return false;
+  }
+  m_MFCCaptureBuffersCount = ctrl.value + MFC_CAPTURE_EXTRA_BUFFER_CNT;
+
+  // Get mfc capture crop
+  memzero(crop);
+  crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  ret = ioctl(m_iDecoderHandle, VIDIOC_G_CROP, &crop);
+  if (ret) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE G_CROP Failed to get crop information", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE G_CROP (%dx%d)", CLASSNAME, __func__, crop.c.width, crop.c.height);
+  m_iDecodedWidth = crop.c.width;
+  m_iDecodedHeight = crop.c.height;
+
+#ifdef USE_FIMC
+  // Setup FIMC OUTPUT crop with data from MFC CAPTURE received on previous step
+  crop.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+  if (ioctl(m_iConverterHandle, VIDIOC_S_CROP, &crop)) {
+    CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT S_CROP Failed to set crop information", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT S_CROP (%dx%d)", CLASSNAME, __func__, crop.c.width, crop.c.height);
+
+  // Calculate FIMC final picture size be scaled to fit screen
+#if MAJOR_VERSION < 13
+  RESOLUTION_INFO& res_info = g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()];
+#else
+  RESOLUTION_INFO res_info =  CDisplaySettings::Get().GetResolutionInfo(g_graphicsContext.GetVideoResolution());
+#endif
+  double ratio = std::min((double)res_info.iScreenWidth / (double)m_iDecodedWidth, (double)res_info.iScreenHeight / (double)m_iDecodedHeight);
+  int width = (int)((double)m_iDecodedWidth * ratio);
+  int height = (int)((double)m_iDecodedHeight * ratio);
+  if (width%2)
+    width--;
+  if (height%2)
+    height--;
+#else
+  // No scaling, resulting picture will be the same size as source
+  int width = m_iDecodedWidth;
+  int height = m_iDecodedHeight;
+#endif
+
+  // Request mfc capture buffers
+  m_MFCCaptureBuffersCount = CLinuxV4l2::RequestBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, m_MFCCaptureBuffersCount);
+  if (m_MFCCaptureBuffersCount == V4L2_ERROR) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE REQBUFS failed", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE REQBUFS Number of buffers is %d (extra %d)", CLASSNAME, __func__, m_MFCCaptureBuffersCount, MFC_CAPTURE_EXTRA_BUFFER_CNT);
+
+  // Allocate, Memory Map and queue mfc capture buffers
+  m_v4l2MFCCaptureBuffers = (V4L2Buffer *)calloc(m_MFCCaptureBuffersCount, sizeof(V4L2Buffer));
+  if(!m_v4l2MFCCaptureBuffers) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Cannot allocate memory for buffers", CLASSNAME, __func__);
+    return false;
+  }
+  if(!CLinuxV4l2::MmapBuffers(m_iDecoderHandle, m_MFCCaptureBuffersCount, m_v4l2MFCCaptureBuffers, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, true)) {
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Cannot mmap memory for buffers", CLASSNAME, __func__);
+    return false;
+  }
+  for (int n = 0; n < m_MFCCaptureBuffersCount; n++) {
+    m_v4l2MFCCaptureBuffers[n].iBytesUsed[0] = m_iMFCCapturePlane1Size;
+    m_v4l2MFCCaptureBuffers[n].iBytesUsed[1] = m_iMFCCapturePlane2Size;
+    m_v4l2MFCCaptureBuffers[n].bQueue = true;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE Succesfully allocated, mmapped and queued %d buffers", CLASSNAME, __func__, m_MFCCaptureBuffersCount);
+
+  // STREAMON on mfc CAPTURE
+  if (!CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMON)) {
+	CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE Failed to Stream ON", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE Stream ON", CLASSNAME, __func__);
+
+#ifdef USE_FIMC
+  // Request fimc capture buffers
+  ret = CLinuxV4l2::RequestBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_USERPTR, m_MFCCaptureBuffersCount);
+  if (ret == V4L2_ERROR) {
+    CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT REQBUFS failed", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT REQBUFS Number of buffers is %d", CLASSNAME, __func__, ret);
+  
+  // Setup fimc capture
+  memzero(fmt);
+  fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_YUV420M;
+  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  fmt.fmt.pix_mp.width = width;
+  fmt.fmt.pix_mp.height = height;
+  fmt.fmt.pix_mp.num_planes = V4L2_NUM_MAX_PLANES;
+  fmt.fmt.pix_mp.field = V4L2_FIELD_ANY;
+  ret = ioctl(m_iConverterHandle, VIDIOC_S_FMT, &fmt);
+  if (ret != 0) {
+    CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE S_FMT Failed", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE S_FMT %dx%d", CLASSNAME, __func__, fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height);
+  m_iConvertedWidth = fmt.fmt.pix_mp.width;
+  m_iConvertedHeight = fmt.fmt.pix_mp.height;
+#else
+  m_iConvertedWidth = width;
+  m_iConvertedHeight = height;
+#endif
+
+#ifdef USE_FIMC
+  // Setup FIMC CAPTURE crop
+  memzero(crop);
+  crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  crop.c.left = 0;
+  crop.c.top = 0;
+  crop.c.width = m_iConvertedWidth;
+  crop.c.height = m_iConvertedHeight;
+  if (ioctl(m_iConverterHandle, VIDIOC_S_CROP, &crop)) {
+    CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE S_CROP Failed", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE S_CROP (%dx%d)", CLASSNAME, __func__, crop.c.width, crop.c.height);
+
+  // Get FIMC produced picture details to adjust output buffer parameters with these values
+  memzero(fmt);
+  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  ret = ioctl(m_iConverterHandle, VIDIOC_G_FMT, &fmt);
+  if (ret) {
+    CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE G_FMT Failed", CLASSNAME, __func__);
+    return false;
+  }
+  m_iFIMCCapturePlane1Size = fmt.fmt.pix_mp.plane_fmt[0].sizeimage;
+  m_iFIMCCapturePlane2Size = fmt.fmt.pix_mp.plane_fmt[1].sizeimage;
+  m_iFIMCCapturePlane3Size = fmt.fmt.pix_mp.plane_fmt[2].sizeimage;
+
+  // Request fimc capture buffers
+  m_FIMCCaptureBuffersCount = CLinuxV4l2::RequestBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, FIMC_CAPTURE_BUFFERS_CNT);
+  if (m_FIMCCaptureBuffersCount == V4L2_ERROR) {
+    CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE REQBUFS failed", CLASSNAME, __func__);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE REQBUFS Number of buffers is %d", CLASSNAME, __func__, m_FIMCCaptureBuffersCount);
+  CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE buffer parameters: plane[0]=%d plane[1]=%d plane[2]=%d", CLASSNAME, __func__, m_iFIMCCapturePlane1Size, m_iFIMCCapturePlane2Size, m_iFIMCCapturePlane3Size);
+
+  // Allocate, Memory Map and queue fimc capture buffers
+  m_v4l2FIMCCaptureBuffers = (V4L2Buffer *)calloc(m_FIMCCaptureBuffersCount, sizeof(V4L2Buffer));
+  if(!m_v4l2FIMCCaptureBuffers) {
+   CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Cannot allocate memory for buffers", CLASSNAME, __func__);
+   return false;
+  }
+  if(!CLinuxV4l2::MmapBuffers(m_iConverterHandle, m_FIMCCaptureBuffersCount, m_v4l2FIMCCaptureBuffers, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, true)) {
+    CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Cannot mmap for capture buffers", CLASSNAME, __func__);
+    return false;
+  }
+  for (int n = 0; n < m_FIMCCaptureBuffersCount; n++) {
+    m_v4l2FIMCCaptureBuffers[n].iBytesUsed[0] = m_iFIMCCapturePlane1Size;
+    m_v4l2FIMCCaptureBuffers[n].iBytesUsed[1] = m_iFIMCCapturePlane2Size;
+    m_v4l2FIMCCaptureBuffers[n].iBytesUsed[2] = m_iFIMCCapturePlane3Size;
+    m_v4l2FIMCCaptureBuffers[n].bQueue = true;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE Succesfully allocated, mmapped and queued %d buffers", CLASSNAME, __func__, m_FIMCCaptureBuffersCount);
+#endif
+
+  // Dequeue header from MFC, we don't need it anymore
+  ret = CLinuxV4l2::DequeueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, V4L2_NUM_MAX_PLANES);
+  if (ret < 0) {
+    CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT error dequeue header, got number %d, errno %d", CLASSNAME, __func__, ret, errno);
+    return false;
+  }
+  m_v4l2MFCOutputBuffers[ret].bQueue = false;
+  CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT -> %d header", CLASSNAME, __func__, ret);
+
+  CLog::Log(LOGNOTICE, "%s::%s - MFC Setup succesfull, start streaming", CLASSNAME, __func__);
+  printf("%s::%s - MFC Setup succesfull, start streaming\n", CLASSNAME, __func__);
+  
+  return true;
+}
+
+void CDVDVideoCodecExynos4::Dispose() {
+  CLog::Log(LOGDEBUG, "%s::%s - Freeing memory allocated for buffers", CLASSNAME, __func__);
+  if (m_v4l2MFCOutputBuffers)
+    m_v4l2MFCOutputBuffers = CLinuxV4l2::FreeBuffers(m_MFCOutputBuffersCount, m_v4l2MFCOutputBuffers);
+  if (m_v4l2MFCCaptureBuffers)
+    m_v4l2MFCCaptureBuffers = CLinuxV4l2::FreeBuffers(m_MFCCaptureBuffersCount, m_v4l2MFCCaptureBuffers);
+  if (m_v4l2FIMCCaptureBuffers)
+    m_v4l2FIMCCaptureBuffers = CLinuxV4l2::FreeBuffers(m_FIMCCaptureBuffersCount, m_v4l2FIMCCaptureBuffers);
+  CLog::Log(LOGDEBUG, "%s::%s - Closing devices", CLASSNAME, __func__);
+  if (m_iDecoderHandle >= 0) {
+    if (CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - MFC OUTPUT Stream OFF", CLASSNAME, __func__);
+    if (CLinuxV4l2::StreamOn(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - MFC CAPTURE Stream OFF", CLASSNAME, __func__);
+    close(m_iDecoderHandle);
+  }
+  if (m_iConverterHandle >= 0) {
+    if (CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT Stream OFF", CLASSNAME, __func__);
+    if (CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMOFF))
+      CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE Stream OFF", CLASSNAME, __func__);
+    close(m_iConverterHandle);
+  }
+
+  while(!m_pts.empty())
+    m_pts.pop();
+  while(!m_dts.empty())
+    m_dts.pop();
+
+  m_iDecodedWidth = 0;
+  m_iDecodedHeight = 0;
+  m_iConvertedWidth = 0;
+  m_iConvertedHeight = 0;
+  m_iDecoderHandle = -1;
+  m_iConverterHandle = -1;
+  m_bVideoConvert = false;
+  m_bDropPictures = false;
+
+  memzero(m_videoBuffer);
+}
+
+void CDVDVideoCodecExynos4::SetDropState(bool bDrop) {
+
+  m_bDropPictures = bDrop;
+
+}
+
+int CDVDVideoCodecExynos4::Decode(BYTE* pData, int iSize, double dts, double pts) {
+  int ret = -1;
+  int index = 0;
+
+//  unsigned int dtime = XbmcThreads::SystemClockMillis();
+
+  if(pData) {
+    int demuxer_bytes = iSize;
+    uint8_t *demuxer_content = pData;
+
+    //printf("%s::%s - Frame of size %d, pts = %f, dts = %f", demuxer_bytes, pts, dts);
+
+	// Find buffer ready to be filled
+    while (index < m_MFCOutputBuffersCount && m_v4l2MFCOutputBuffers[index].bQueue)
+      index++;
+
+    if (index >= m_MFCOutputBuffersCount) { //all input buffers are busy, dequeue needed
+      ret = CLinuxV4l2::PollOutput(m_iDecoderHandle, 1000); // POLLIN - Capture, POLLOUT - Output
+      if (ret == V4L2_ERROR) {
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT PollOutput Error", CLASSNAME, __func__);
+        return VC_ERROR;
+      } else if (ret == V4L2_READY) {
+        index = CLinuxV4l2::DequeueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, V4L2_NUM_MAX_PLANES);
+        if (index < 0) {
+          CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT error dequeue output buffer, got number %d, errno %d", CLASSNAME, __func__, index, errno);
+          return VC_ERROR;
+        }
+        //printf("\e[1;32mMFC OUTPUT\e[0m -> %d", index);
+        m_v4l2MFCOutputBuffers[index].bQueue = false;
+      } else if (ret == V4L2_BUSY) { // buffer is still busy
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT All buffers are queued and busy, no space for new frame to decode. Very broken situation.", CLASSNAME, __func__);
+        /* FIXME This should be handled as abnormal situation that should be addressed, otherwise decoding will stuck here forever */
+        return VC_FLUSHED;
+      } else {
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT\e[0m PollOutput error %d, errno %d", CLASSNAME, __func__, ret, errno);
+        return VC_ERROR;
+      }
+    }
+
+    if(m_bVideoConvert) {
+      m_converter.Convert(demuxer_content, demuxer_bytes);
+      demuxer_bytes = m_converter.GetConvertSize();
+      demuxer_content = m_converter.GetConvertBuffer();
+    }
+
+    if(demuxer_bytes < m_v4l2MFCOutputBuffers[index].iSize[0]) {
+      m_pts.push(-pts);
+      m_dts.push(-dts);
+
+      fast_memcpy((uint8_t *)m_v4l2MFCOutputBuffers[index].cPlane[0], demuxer_content, demuxer_bytes);
+      m_v4l2MFCOutputBuffers[index].iBytesUsed[0] = demuxer_bytes;
+
+      ret = CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_MMAP, m_v4l2MFCOutputBuffers[index].iNumPlanes, index, &m_v4l2MFCOutputBuffers[index]);
+      if (ret == V4L2_ERROR) {
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, index, errno);
+        return VC_ERROR;
+      }
+      m_v4l2MFCOutputBuffers[index].bQueue = true;
+      //printf("\e[1;32mMFC OUTPUT\e[0m %d <-", ret);
+    } else
+      CLog::Log(LOGERROR, "%s::%s - Packet to big for streambuffer", CLASSNAME, __func__);
+  }
+
+  // Dequeue decoded frame
+  index = CLinuxV4l2::DequeueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, V4L2_NUM_MAX_PLANES);
+  if (index < 0) {
+    if (errno == EAGAIN) // Buffer is still busy, queue more
+      return VC_BUFFER;
+    CLog::Log(LOGERROR, "%s::%s - MFC CAPTURE error dequeue output buffer, got number %d, errno %d", CLASSNAME, __func__, ret, errno);
+    return VC_ERROR;
+  }
+  //printf("\e[1;32mMFC CAPTURE\e[0m -> %d", index);
+  m_v4l2MFCCaptureBuffers[index].bQueue = false;
+
+  if (m_bDropPictures) {
+    m_videoBuffer.iFlags      |= DVP_FLAG_DROPPED;
+    CLog::Log(LOGDEBUG, "%s::%s - Dropping frame with index %d", CLASSNAME, __func__, index);
+  } else {
+#ifdef USE_FIMC
+    if (m_iFIMCdequeuedBufferNumber >= 0 && !m_v4l2FIMCCaptureBuffers[m_iFIMCdequeuedBufferNumber].bQueue) {
+      ret = CLinuxV4l2::QueueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, m_v4l2FIMCCaptureBuffers[m_iFIMCdequeuedBufferNumber].iNumPlanes, m_iFIMCdequeuedBufferNumber, &m_v4l2FIMCCaptureBuffers[m_iFIMCdequeuedBufferNumber]);
+      if (ret == V4L2_ERROR) {
+        CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Failed to queue buffer with index %d, errno = %d", CLASSNAME, __func__, m_iFIMCdequeuedBufferNumber, errno);
+        return VC_ERROR;
+      }
+      //printf("\e[1;31mFIMC CAPTURE\e[0m %d <-", ret);
+      m_v4l2FIMCCaptureBuffers[ret].bQueue = true;
+      m_iFIMCdequeuedBufferNumber = -1;
+    }
+
+    ret = CLinuxV4l2::QueueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_USERPTR, m_v4l2MFCCaptureBuffers[index].iNumPlanes, index, &m_v4l2MFCCaptureBuffers[index]);
+    if (ret == V4L2_ERROR) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT Failed to queue buffer with index %d, errno %d", CLASSNAME, __func__, ret, errno);
+      return VC_ERROR;
+    }
+    m_v4l2MFCCaptureBuffers[ret].bQueue = true;
+    //printf("\e[1;31mFIMC OUTPUT\e[0m %d <-", ret);
+
+    if (m_bFIMCStartConverter) {
+      if (CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, VIDIOC_STREAMON))
+        CLog::Log(LOGDEBUG, "%s::%s - FIMC OUTPUT Stream ON", CLASSNAME, __func__);
+      else
+        CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT Failed to Stream ON", CLASSNAME, __func__);
+      if (CLinuxV4l2::StreamOn(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, VIDIOC_STREAMON))
+        CLog::Log(LOGDEBUG, "%s::%s - FIMC CAPTURE Stream ON", CLASSNAME, __func__);
+      else
+        CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE Failed to Stream ON", CLASSNAME, __func__);
+      m_bFIMCStartConverter = false;
+      return VC_BUFFER; //Queue one more frame for double buffering on FIMC
+    }
+
+    ret = CLinuxV4l2::PollOutput(m_iConverterHandle, 1000/25); // 25 fps
+    if (ret == V4L2_ERROR) {
+      CLog::Log(LOGERROR, "%s::%s - FIMC PollOutput Error", CLASSNAME, __func__);
+      return VC_ERROR;
+    } else if (ret == V4L2_READY) {
+      // Dequeue frame from fimc output
+      index = CLinuxV4l2::DequeueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE, V4L2_MEMORY_USERPTR, V4L2_NUM_MAX_PLANES);
+      if (index < 0) {
+        CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT error dequeue output buffer, got number %d", CLASSNAME, __func__, index);
+        return VC_ERROR;
+      }
+      //printf("\e[1;31mFIMC OUTPUT\e[0m -> %d", index);
+      m_v4l2MFCCaptureBuffers[index].bQueue = false;
+    } else if (ret == V4L2_BUSY) { // buffer is still busy
+      CLog::Log(LOGERROR, "%s::%s - FIMC OUTPUT Buffer is still busy", CLASSNAME, __func__);
+      return VC_ERROR;
+    } else {
+      CLog::Log(LOGERROR, "%s::%s - FIMC PollOutput error %d, errno %d", CLASSNAME, __func__, ret, errno);
+      return VC_ERROR;
+    }
+
+    m_iFIMCdequeuedBufferNumber = CLinuxV4l2::DequeueBuffer(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, V4L2_NUM_MAX_PLANES);
+    if (m_iFIMCdequeuedBufferNumber < 0) {
+      if (errno == EAGAIN) // Dequeue buffer not ready, need more data on input. EAGAIN = 11
+        return VC_BUFFER;
+      CLog::Log(LOGERROR, "%s::%s - FIMC CAPTURE error dequeue output buffer, got number %d, errno %d", CLASSNAME, __func__, m_iFIMCdequeuedBufferNumber, errno);
+      return VC_ERROR;
+    }
+    //printf("\e[1;31mFIMC CAPTURE\e[0m -> %d", m_iFIMCdequeuedBufferNumber);
+    m_v4l2FIMCCaptureBuffers[m_iFIMCdequeuedBufferNumber].bQueue = false;
+#endif
+
+    m_videoBuffer.iFlags          = DVP_FLAG_ALLOCATED;
+    m_videoBuffer.color_range     = 0;
+    m_videoBuffer.color_matrix    = 4;
+
+    m_videoBuffer.iDisplayWidth   = m_iConvertedWidth;
+    m_videoBuffer.iDisplayHeight  = m_iConvertedHeight;
+    m_videoBuffer.iWidth          = m_iConvertedWidth;
+    m_videoBuffer.iHeight         = m_iConvertedHeight;
+
+    m_videoBuffer.data[0]         = 0;
+    m_videoBuffer.data[1]         = 0;
+    m_videoBuffer.data[2]         = 0;
+    m_videoBuffer.data[3]         = 0;
+    
+#ifdef USE_FIMC
+    m_videoBuffer.format          = RENDER_FMT_YUV420P;
+    m_videoBuffer.iLineSize[0]    = m_iConvertedWidth;
+    m_videoBuffer.iLineSize[1]    = m_iConvertedWidth >> 1;
+    m_videoBuffer.iLineSize[2]    = m_iConvertedWidth >> 1;
+    m_videoBuffer.iLineSize[3]    = 0;
+    m_videoBuffer.data[0]         = (BYTE*)m_v4l2FIMCCaptureBuffers[m_iFIMCdequeuedBufferNumber].cPlane[0];
+    m_videoBuffer.data[1]         = (BYTE*)m_v4l2FIMCCaptureBuffers[m_iFIMCdequeuedBufferNumber].cPlane[1];
+    m_videoBuffer.data[2]         = (BYTE*)m_v4l2FIMCCaptureBuffers[m_iFIMCdequeuedBufferNumber].cPlane[2];
+#else
+    m_videoBuffer.format          = RENDER_FMT_NV12MT;
+    m_videoBuffer.iLineSize[0]    = m_iConvertedWidth;
+    m_videoBuffer.iLineSize[1]    = m_iConvertedWidth;
+    m_videoBuffer.iLineSize[2]    = 0;
+    m_videoBuffer.iLineSize[3]    = 0;
+    m_videoBuffer.data[0]         = (BYTE*)m_v4l2MFCCaptureBuffers[index].cPlane[0];
+    m_videoBuffer.data[1]         = (BYTE*)m_v4l2MFCCaptureBuffers[index].cPlane[1];
+#endif
+  }
+
+  // Pop pts/dts only when picture is finally ready to be showed up or skipped
+  if(m_pts.size()) {
+    m_videoBuffer.pts = -m_pts.top(); // MFC always return frames in order and assigning them their pts'es from the input
+                                      // will lead to reshuffle. This will assign least pts in the queue to the frame dequeued.
+    m_videoBuffer.dts = -m_dts.top();
+    
+    m_pts.pop();
+    m_dts.pop();
+  } else {
+    CLog::Log(LOGERROR, "%s::%s - no pts value", CLASSNAME, __func__);
+    m_videoBuffer.pts           = DVD_NOPTS_VALUE;
+    m_videoBuffer.dts           = DVD_NOPTS_VALUE;
+  }
+
+  // Queue dequeued from FIMC OUPUT frame back to MFC CAPTURE
+  if (&m_v4l2MFCCaptureBuffers[index] && !m_v4l2MFCCaptureBuffers[index].bQueue) {
+    int ret = CLinuxV4l2::QueueBuffer(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE, V4L2_MEMORY_MMAP, m_v4l2MFCCaptureBuffers[index].iNumPlanes, index, &m_v4l2MFCCaptureBuffers[index]);
+    if (ret < 0) {
+      CLog::Log(LOGERROR, "%s::%s - queue output buffer\n", CLASSNAME, __func__);
+      m_videoBuffer.iFlags      |= DVP_FLAG_DROPPED;
+      m_videoBuffer.iFlags      &= DVP_FLAG_ALLOCATED;
+      return VC_ERROR;
+    }
+    m_v4l2MFCCaptureBuffers[index].bQueue = true;
+    //printf("\e[1;32mMFC CAPTURE\e[0m <- %d", ret);
+  }
+
+//  msg("Decode time: %d", XbmcThreads::SystemClockMillis() - dtime);
+  
+  return VC_PICTURE; // Picture is finally ready to be processed further
+}
+
+void CDVDVideoCodecExynos4::Reset() {
+
+}
+
+bool CDVDVideoCodecExynos4::GetPicture(DVDVideoPicture* pDvdVideoPicture) {
+
+  *pDvdVideoPicture = m_videoBuffer;
+
+  return true;
+}
+
+bool CDVDVideoCodecExynos4::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  return CDVDVideoCodec::ClearPicture(pDvdVideoPicture);
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecExynos4.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecExynos4.h
new file mode 100644
index 0000000..5a3a484
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecExynos4.h
@@ -0,0 +1,106 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DVDVideoCodec.h"
+#include "DVDResource.h"
+#include "utils/BitstreamConverter.h"
+#include "xbmc/linux/LinuxV4l2.h"
+#include <string>
+#include <queue>
+#include <list>
+#include "guilib/GraphicContext.h"
+
+#define STREAM_BUFFER_SIZE            786432 //compressed frame size. 1080p mpeg4 10Mb/s can be un to 786k in size, so this is to make sure frame fits into buffer
+#define FIMC_CAPTURE_BUFFERS_CNT      3 //2 begins to be slow.
+#define MFC_OUTPUT_BUFFERS_CNT        2 //1 doesn't work at all
+#define MFC_CAPTURE_EXTRA_BUFFER_CNT  3 //these are extra buffers, better keep their count as big as going to be simultaneous dequeued buffers number
+
+#ifndef V4L2_CAP_VIDEO_M2M_MPLANE
+  #define V4L2_CAP_VIDEO_M2M_MPLANE       0x00004000
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+class CDVDVideoCodecExynos4 : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecExynos4();
+  virtual ~CDVDVideoCodecExynos4();
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose();
+  virtual int Decode(BYTE* pData, int iSize, double dts, double pts);
+  virtual void Reset();
+  bool GetPictureCommon(DVDVideoPicture* pDvdVideoPicture);
+  virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
+
+protected:
+  std::string m_name;
+  unsigned int m_iDecodedWidth;
+  unsigned int m_iDecodedHeight;
+  unsigned int m_iConvertedWidth;
+  unsigned int m_iConvertedHeight;
+  int m_iDecoderHandle;
+  int m_iConverterHandle;
+
+  int m_MFCOutputBuffersCount;
+  int m_MFCCaptureBuffersCount;
+  int m_FIMCOutputBuffersCount;
+  int m_FIMCCaptureBuffersCount;
+
+  int m_iMFCCapturePlane1Size;
+  int m_iMFCCapturePlane2Size;
+  int m_iFIMCCapturePlane1Size;
+  int m_iFIMCCapturePlane2Size;
+  int m_iFIMCCapturePlane3Size;
+
+  V4L2Buffer *m_v4l2MFCOutputBuffers;
+  V4L2Buffer *m_v4l2MFCCaptureBuffers;
+  V4L2Buffer *m_v4l2FIMCOutputBuffers;
+  V4L2Buffer *m_v4l2FIMCCaptureBuffers;
+  
+  int m_iFIMCdequeuedBufferNumber;
+  
+  bool m_bVideoConvert;
+
+  CBitstreamConverter m_converter;
+
+  std::priority_queue<double> m_pts;
+  std::priority_queue<double> m_dts;
+
+  bool m_bDropPictures;
+
+  DVDVideoPicture   m_videoBuffer;
+  bool m_bFIMCStartConverter;
+
+  bool OpenDevices();
+};
+
+#define memzero(x) memset(&(x), 0, sizeof (x))
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
index 176ceff..a430f75 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
@@ -22,6 +22,12 @@ SRCS += OpenMax.cpp
 SRCS += OpenMaxVideo.cpp
 SRCS += DVDVideoCodecOpenMax.cpp
 endif
+ifeq (@USE_EXYNOS4@,1)
+SRCS += DVDVideoCodecExynos4.cpp
+endif
+ifeq (@USE_EXYNOS5@,1)
+SRCS += DVDVideoCodecExynos5.cpp
+endif
 
 LIB=Video.a
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 3008c25..87f6f16 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1103,6 +1103,9 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
       case RENDER_FMT_NV12:
         formatstr = "NV12";
         break;
+      case RENDER_FMT_NV12MT:
+        formatstr = "NV12MT";
+        break; 
       case RENDER_FMT_UYVY422:
         formatstr = "UYVY";
         break;
@@ -1346,6 +1349,7 @@ void CDVDPlayerVideo::AutoCrop(DVDVideoPicture *pPicture)
 {
   if ((pPicture->format == RENDER_FMT_YUV420P) ||
      (pPicture->format == RENDER_FMT_NV12) ||
+     (pPicture->format == RENDER_FMT_NV12MT) ||
      (pPicture->format == RENDER_FMT_YUYV422) ||
      (pPicture->format == RENDER_FMT_UYVY422))
   {
diff --git a/xbmc/linux/LinuxV4l2.cpp b/xbmc/linux/LinuxV4l2.cpp
new file mode 100644
index 0000000..696baf2
--- /dev/null
+++ b/xbmc/linux/LinuxV4l2.cpp
@@ -0,0 +1,301 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#if (defined HAVE_CONFIG_H) && (!defined WIN32)
+  #include "config.h"
+#endif
+#include "LinuxV4l2.h"
+
+#include "xbmc/utils/log.h"
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <linux/media.h>
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CLinuxV4l2"
+
+CLinuxV4l2::CLinuxV4l2() 
+{
+}
+
+CLinuxV4l2::~CLinuxV4l2()
+{
+}
+
+int CLinuxV4l2::RequestBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, int numBuffers)
+{
+  struct v4l2_requestbuffers reqbuf;
+  int ret = 0;
+
+  if(device < 0)
+    return false;
+
+  memset(&reqbuf, 0, sizeof(struct v4l2_requestbuffers));
+
+  reqbuf.type     = type;
+  reqbuf.memory   = memory;
+  reqbuf.count    = numBuffers;
+
+  ret = ioctl(device, VIDIOC_REQBUFS, &reqbuf);
+  if (ret)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Request buffers", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+
+  return reqbuf.count;
+}
+
+bool CLinuxV4l2::StreamOn(int device, enum v4l2_buf_type type, int onoff)
+{
+  int ret = 0;
+  enum v4l2_buf_type setType = type;
+
+  if(device < 0)
+    return false;
+
+  ret = ioctl(device, onoff, &setType);
+  if(ret)
+    return false;
+
+  return true;
+}
+
+bool CLinuxV4l2::MmapBuffers(int device, int count, V4L2Buffer *v4l2Buffers, enum v4l2_buf_type type, enum v4l2_memory memory, bool queue)
+{
+  struct v4l2_buffer buf;
+  struct v4l2_plane planes[V4L2_NUM_MAX_PLANES];
+  int ret;
+  int i, j;
+
+  if(device < 0 || !v4l2Buffers || count == 0)
+    return false;
+
+  for(i = 0; i < count; i++)
+  {
+    memset(&buf, 0, sizeof(struct v4l2_buffer));
+    memset(&planes, 0, sizeof(struct v4l2_plane) * V4L2_NUM_MAX_PLANES);
+    buf.type      = type;
+    buf.memory    = memory;
+    buf.index     = i;
+    buf.m.planes  = planes;
+    buf.length    = V4L2_NUM_MAX_PLANES;
+
+    ret = ioctl(device, VIDIOC_QUERYBUF, &buf);
+    if (ret)
+    {
+      CLog::Log(LOGERROR, "%s::%s - Query buffer", CLASSNAME, __func__);
+      return false;
+    }
+
+    V4L2Buffer *buffer = &v4l2Buffers[i];
+
+    buffer->iNumPlanes = 0;
+    for (j = 0; j < V4L2_NUM_MAX_PLANES; j++) 
+    {
+      //printf("%s::%s - plane %d %d size %d 0x%08x\n", CLASSNAME, __func__, i, j, buf.m.planes[j].length,
+      //    buf.m.planes[j].m.userptr);
+      buffer->iSize[j]       = buf.m.planes[j].length;
+      buffer->iBytesUsed[j]  = buf.m.planes[j].bytesused;
+      if(buffer->iSize[j])
+      {
+        buffer->cPlane[j] = mmap(NULL, buf.m.planes[j].length, PROT_READ | PROT_WRITE,
+                       MAP_SHARED, device, buf.m.planes[j].m.mem_offset);
+        if(buffer->cPlane[j] == MAP_FAILED)
+        {
+          CLog::Log(LOGERROR, "%s::%s - Mmapping buffer", CLASSNAME, __func__);
+          return false;
+        }
+        memset(buffer->cPlane[j], 0, buf.m.planes[j].length);
+        buffer->iNumPlanes++;
+      }
+    }
+    buffer->iIndex = i;
+
+    if(queue)
+    {
+      ret = ioctl(device, VIDIOC_QBUF, &buf);
+      if (ret)
+      {
+        CLog::Log(LOGERROR, "%s::%s - Queue buffer", CLASSNAME, __func__);
+        return false;
+      }
+      buffer->bQueue = true;
+    }
+  }
+
+  return true;
+}
+
+V4L2Buffer *CLinuxV4l2::FreeBuffers(int count, V4L2Buffer *v4l2Buffers)
+{
+  int i, j;
+
+  if(v4l2Buffers != NULL)
+  {
+    for(i = 0; i < count; i++)
+    {
+      V4L2Buffer *buffer = &v4l2Buffers[i];
+
+      for (j = 0; j < buffer->iNumPlanes; j++)
+      {
+        if(buffer->cPlane[j] && buffer->cPlane[j] != MAP_FAILED)
+        {
+          munmap(buffer->cPlane[j], buffer->iSize[j]);
+          CLog::Log(LOGDEBUG, "%s::%s - unmap convert buffer", CLASSNAME, __func__);
+        }
+      }
+    }
+    free(v4l2Buffers);
+  }
+  return NULL;
+}
+
+int CLinuxV4l2::DequeueBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, int planes)
+{
+  struct v4l2_buffer vbuf;
+  struct v4l2_plane  vplanes[V4L2_NUM_MAX_PLANES];
+  int ret = 0;
+
+  if(device < 0)
+    return V4L2_ERROR;
+
+  memset(&vplanes, 0, sizeof(struct v4l2_plane) * V4L2_NUM_MAX_PLANES);
+  memset(&vbuf, 0, sizeof(struct v4l2_buffer));
+  vbuf.type     = type;
+  vbuf.memory   = memory;
+  vbuf.m.planes = vplanes;
+  vbuf.length   = planes;
+
+  ret = ioctl(device, VIDIOC_DQBUF, &vbuf);
+  if (ret) {
+    if (errno != EAGAIN)
+      CLog::Log(LOGERROR, "%s::%s - Dequeue buffer", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+  
+  return vbuf.index;
+}
+
+int CLinuxV4l2::QueueBuffer(int device, enum v4l2_buf_type type, 
+    enum v4l2_memory memory, int planes, int index, V4L2Buffer *buffer)
+{
+  struct v4l2_buffer vbuf;
+  struct v4l2_plane  vplanes[V4L2_NUM_MAX_PLANES];
+  int ret = 0;
+
+  if(!buffer || device <0)
+    return V4L2_ERROR;
+
+  memset(&vplanes, 0, sizeof(struct v4l2_plane) * V4L2_NUM_MAX_PLANES);
+  memset(&vbuf, 0, sizeof(struct v4l2_buffer));
+  vbuf.type     = type;
+  vbuf.memory   = memory;
+  vbuf.index    = index;
+  vbuf.m.planes = vplanes;
+  vbuf.length   = buffer->iNumPlanes;
+
+  for (int i = 0; i < buffer->iNumPlanes; i++) 
+  {
+    vplanes[i].m.userptr   = (unsigned long)buffer->cPlane[i];
+    vplanes[i].length      = buffer->iSize[i];
+    vplanes[i].bytesused   = buffer->iBytesUsed[i];
+  }
+
+  ret = ioctl(device, VIDIOC_QBUF, &vbuf);
+  if (ret)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Queue buffer", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+  buffer->bQueue = true;
+
+  return index;
+}
+
+int CLinuxV4l2::PollInput(int device, int timeout)
+{
+  int ret = 0;
+  struct pollfd p;
+  p.fd = device;
+  p.events = POLLIN | POLLERR;
+
+  ret = poll(&p, 1, timeout);
+  if (ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Polling input", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+  else if (ret == 0)
+  {
+    return V4L2_BUSY;
+  }
+
+  return V4L2_READY;
+}
+
+int CLinuxV4l2::PollOutput(int device, int timeout)
+{
+  int ret = 0;
+  struct pollfd p;
+  p.fd = device;
+  p.events = POLLOUT | POLLERR;
+
+  ret = poll(&p, 1, timeout);
+  if (ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s::%s - Polling output", CLASSNAME, __func__);
+    return V4L2_ERROR;
+  }
+  else if (ret == 0)
+  {
+    return V4L2_BUSY;
+  }
+
+  return V4L2_READY;
+}
+
+int CLinuxV4l2::SetControllValue(int device, int id, int value)
+{
+  struct v4l2_control control;
+  int ret;
+
+  control.id    = id;
+  control.value = value;
+
+  ret = ioctl(device, VIDIOC_S_CTRL, &control);
+
+  if(ret < 0) 
+  {
+    CLog::Log(LOGERROR, "%s::%s - Set controll if %d value %d\n", CLASSNAME, __func__, id, value);
+    return V4L2_ERROR;
+  }
+
+  return V4L2_OK;
+}
diff --git a/xbmc/linux/LinuxV4l2.h b/xbmc/linux/LinuxV4l2.h
new file mode 100644
index 0000000..fccad68
--- /dev/null
+++ b/xbmc/linux/LinuxV4l2.h
@@ -0,0 +1,74 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/videodev2.h>
+
+#define V4L2_ERROR -1
+#define V4L2_BUSY  1
+#define V4L2_READY 2
+#define V4L2_OK    3
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define V4L2_NUM_MAX_PLANES 3
+
+typedef struct V4L2Buffer
+{
+  int   iSize[V4L2_NUM_MAX_PLANES];
+  int   iOffset[V4L2_NUM_MAX_PLANES];
+  int   iBytesUsed[V4L2_NUM_MAX_PLANES];
+  void  *cPlane[V4L2_NUM_MAX_PLANES];
+  int   iNumPlanes;
+  int   iIndex;
+  bool  bQueue;
+} V4L2Buffer;
+
+#ifdef __cplusplus
+}
+#endif
+
+class CLinuxV4l2
+{
+public:
+  CLinuxV4l2();
+  virtual ~CLinuxV4l2();
+
+  static int RequestBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, int numBuffers);
+  static bool StreamOn(int device, enum v4l2_buf_type type, int onoff);
+  static bool MmapBuffers(int device, int count, V4L2Buffer *v4l2Buffers, enum v4l2_buf_type type, enum v4l2_memory memory, bool queue = true);
+  static V4L2Buffer *FreeBuffers(int count, V4L2Buffer *v4l2Buffers);
+
+  static int DequeueBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, int planes);
+  static int QueueBuffer(int device, enum v4l2_buf_type type, enum v4l2_memory memory, 
+      int planes, int index, V4L2Buffer *buffer);
+
+  static int PollInput(int device, int timeout);
+  static int PollOutput(int device, int timeout);
+  static int SetControllValue(int device, int id, int value);
+};
+
+inline int v4l2_align(int v, int a) {
+  return ((v + a - 1) / a) * a;
+}
+
diff --git a/xbmc/linux/Makefile.in b/xbmc/linux/Makefile.in
index 7bf701c..e2a07ec 100644
--- a/xbmc/linux/Makefile.in
+++ b/xbmc/linux/Makefile.in
@@ -7,6 +7,7 @@ SRCS += DBusReserve.cpp
 SRCS += HALManager.cpp
 SRCS += LinuxResourceCounter.cpp
 SRCS += LinuxTimezone.cpp
+SRCS += LinuxV4l2.cpp
 SRCS += PosixMountProvider.cpp
 SRCS += XFileUtils.cpp
 SRCS += XHandle.cpp
diff --git a/xbmc/utils/CPUInfo.cpp b/xbmc/utils/CPUInfo.cpp
index 76ddb76..8249acb 100644
--- a/xbmc/utils/CPUInfo.cpp
+++ b/xbmc/utils/CPUInfo.cpp
@@ -235,6 +235,11 @@ static inline int _private_gettimeofday( struct timeval *tv, void *tz )
   // read from the new location of the temperature data on new kernels, 2.6.39, 3.0 etc
   if (m_fProcTemperature == NULL)   
     m_fProcTemperature = fopen("/sys/class/hwmon/hwmon0/temp1_input", "r");
+  // ODROID
+  if (m_fProcTemperature == NULL)
+    m_fProcTemperature = fopen("/sys/devices/virtual/thermal/thermal_zone0/temp", "r");
+  if (m_fProcTemperature == NULL)
+    m_fProcTemperature = fopen("/sys/devices/platform/tmu/temperature", "r");  
   
   m_fCPUInfo = fopen("/proc/cpuinfo", "r");
   m_cpuCount = 0;
diff --git a/xbmc/windowing/X11/WinSystemX11GLES.cpp b/xbmc/windowing/X11/WinSystemX11GLES.cpp
index 50185f9..48df722 100644
--- a/xbmc/windowing/X11/WinSystemX11GLES.cpp
+++ b/xbmc/windowing/X11/WinSystemX11GLES.cpp
@@ -26,6 +26,7 @@
 #include <SDL/SDL_syswm.h>
 #include "filesystem/SpecialProtocol.h"
 #include "settings/Settings.h"
+#include "guilib/GraphicContext.h"
 #include "guilib/Texture.h"
 #include "windowing/X11/XRandR.h"
 #include <vector>
@@ -140,11 +141,8 @@ bool CWinSystemX11GLES::DestroyWindowSystem()
     m_eglDisplay = 0;
   }
 
-  if (m_dpy)
-  {
-    XCloseDisplay(m_dpy);
-    m_dpy = NULL;
-  }
+  //we don't call XCloseDisplay() here, since ati keeps a pointer to our m_dpy
+  //so instead we just let m_dpy die on exit
 
   return true;
 }
@@ -154,11 +152,12 @@ bool CWinSystemX11GLES::CreateNewWindow(const CStdString& name, bool fullScreen,
   if(!SetFullScreen(fullScreen, res, false))
 	return false;
 
-  CTexture iconTexture;
-  iconTexture.LoadFromFile("special://xbmc/media/icon.png");
+  CBaseTexture* iconTexture = CTexture::LoadFromFile("special://xbmc/media/icon.png");
 
-  SDL_WM_SetIcon(SDL_CreateRGBSurfaceFrom(iconTexture.GetPixels(), iconTexture.GetWidth(), iconTexture.GetHeight(), BPP, iconTexture.GetPitch(), 0xff0000, 0x00ff00, 0x0000ff, 0xff000000L), NULL);
+  if (iconTexture)
+    SDL_WM_SetIcon(SDL_CreateRGBSurfaceFrom(iconTexture->GetPixels(), iconTexture->GetWidth(), iconTexture->GetHeight(), 32, iconTexture->GetPitch(), 0xff0000, 0x00ff00, 0x0000ff, 0xff000000L), NULL);
   SDL_WM_SetCaption("XBMC Media Center", NULL);
+  delete iconTexture;
 
   m_bWindowCreated = true;
 
diff --git a/xbmc/windowing/egl/EGLNativeTypeOdroid.cpp b/xbmc/windowing/egl/EGLNativeTypeOdroid.cpp
new file mode 100644
index 0000000..048b4c5
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeOdroid.cpp
@@ -0,0 +1,245 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <EGL/egl.h>
+#include "EGLNativeTypeOdroid.h"
+#include "utils/log.h"
+#include <stdlib.h>
+#include "guilib/gui3d.h"
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+#include <unistd.h>
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CEGLNativeTypeOdroid"
+
+CEGLNativeTypeOdroid::CEGLNativeTypeOdroid()
+{
+}
+
+CEGLNativeTypeOdroid::~CEGLNativeTypeOdroid()
+{
+}
+
+bool CEGLNativeTypeOdroid::CheckCompatibility()
+{
+    FILE* m_fCPUInfo = fopen("/proc/cpuinfo", "r");
+    if (m_fCPUInfo)
+    {
+      char buffer[512];
+
+      while (fgets(buffer, sizeof(buffer), m_fCPUInfo))
+      {
+        if (strncmp(buffer, "Hardware", strlen("Hardware"))==0)
+        {
+          char *needle = strstr(buffer, ":");
+          if (needle && strlen(needle)>3)
+          {
+            needle+=2;
+            if (strncmp(needle, "ODROID", strlen("ODROID"))==0) {
+                printf("%s::%s using odroid EGL\n", CLASSNAME, __func__);
+                return true;
+            }
+          }
+        }
+      }
+    }
+
+    return false;
+}
+
+void CEGLNativeTypeOdroid::Initialize()
+{
+  return;
+}
+
+void CEGLNativeTypeOdroid::Destroy()
+{
+  return;
+}
+
+bool CEGLNativeTypeOdroid::CreateNativeDisplay()
+{
+  m_nativeDisplay = XOpenDisplay(NULL);
+  if (m_nativeDisplay)
+    return true;
+  return false;
+}
+
+bool CEGLNativeTypeOdroid::CreateNativeWindow()
+{
+    if (!m_nativeDisplay) 
+      return false;
+
+    Display *xDisplay;
+    Window nativeWindow;
+    Pixmap bitmapNoData;
+    XColor black;
+    static char noData[] = { 0,0,0,0,0,0,0,0 };
+    XWindowAttributes window_attr;
+    XSetWindowAttributes attr;
+    XSetWindowAttributes xattr;
+    XWMHints hints;
+    
+    xDisplay = (Display*) m_nativeDisplay;
+    Window rootWindow = DefaultRootWindow(xDisplay);
+    XGetWindowAttributes(xDisplay, rootWindow, &window_attr);
+    attr.background_pixel = 0;
+    attr.border_pixel = 0;
+    attr.event_mask = ExposureMask | PointerMotionMask | KeyPressMask;
+    nativeWindow = XCreateWindow(xDisplay, rootWindow, 0, 0, window_attr.width, window_attr.height, 0, CopyFromParent, InputOutput, CopyFromParent, CWBackPixel | CWBorderPixel | CWEventMask, &attr);
+    xattr.override_redirect = 0;
+    XChangeWindowAttributes ( xDisplay, nativeWindow, CWOverrideRedirect, &xattr );
+    hints.input = 1;
+    hints.flags = InputHint;
+    XSetWMHints(xDisplay, nativeWindow, &hints);
+
+    black.red = black.green = black.blue = 0;
+    bitmapNoData = XCreateBitmapFromData(xDisplay, nativeWindow, noData, 8, 8);
+    Cursor invisibleCursor = XCreatePixmapCursor(xDisplay, bitmapNoData, bitmapNoData, &black, &black, 0, 0);
+    XDefineCursor(xDisplay, nativeWindow, invisibleCursor);
+    XFreeCursor(xDisplay, invisibleCursor);
+/*
+   {
+      XEvent	x11_event;
+      Atom	x11_state_atom;
+      Atom	x11_fs_atom;
+
+      x11_state_atom	= XInternAtom(xDisplay, "_NET_WM_STATE", True);
+      x11_fs_atom		= XInternAtom(xDisplay, "_NET_WM_STATE_FULLSCREEN", True);
+
+      x11_event.xclient.type			= ClientMessage;
+      x11_event.xclient.serial		= 0;
+      x11_event.xclient.send_event	= True;
+      x11_event.xclient.window		= nativeWindow;
+      x11_event.xclient.message_type	= x11_state_atom;
+      x11_event.xclient.format		= 32;
+      x11_event.xclient.data.l[0]	= 1;
+      x11_event.xclient.data.l[1]	= x11_fs_atom;
+      x11_event.xclient.data.l[2]	= 0;
+
+      XSendEvent(xDisplay, rootWindow, False, SubstructureRedirectMask | SubstructureNotifyMask, &x11_event);
+    }
+*/
+
+    Atom atom[2] = { XInternAtom(xDisplay, "_NET_WM_STATE_FULLSCREEN", False), None };
+    XChangeProperty(xDisplay, nativeWindow, XInternAtom(xDisplay, "_NET_WM_STATE", False), XA_ATOM, 32, PropModeReplace, (const unsigned char *)atom,  1);
+
+    XStoreName(xDisplay , nativeWindow,  "XBMC");
+
+    XFlush(xDisplay);
+
+    m_nativeWindow = (EGLNativeWindowType) nativeWindow;
+
+    if (!m_nativeWindow)
+      return false;
+
+    return true;
+}
+
+bool CEGLNativeTypeOdroid::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)
+    return false;
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeOdroid::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  if (!nativeWindow)
+    return false;
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeOdroid::DestroyNativeDisplay()
+{
+  XCloseDisplay((Display *) m_nativeDisplay);
+  free(m_nativeDisplay);
+  return true;
+}
+
+bool CEGLNativeTypeOdroid::DestroyNativeWindow()
+{
+  free(m_nativeWindow);
+  return true;
+}
+
+bool CEGLNativeTypeOdroid::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+    XWindowAttributes window_attr;
+    XGetWindowAttributes((Display *) m_nativeDisplay, (Window) m_nativeWindow, &window_attr);
+    res->iWidth         = window_attr.width;
+    res->iHeight        = window_attr.height;
+    res->iScreenWidth   = res->iWidth;
+    res->iScreenHeight  = res->iHeight;
+    res->fRefreshRate   = 60;
+    res->dwFlags        = D3DPRESENTFLAG_PROGRESSIVE;
+    res->iScreen        = 0;
+    res->bFullScreen    = true;
+    res->iSubtitles     = (int)(0.965 * res->iHeight);
+    res->fPixelRatio    = 1.0f;
+    res->strMode.Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate, res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+    CLog::Log(LOGNOTICE,"Current resolution: %dx%d\n", window_attr.width, window_attr.height);
+    return true;
+}
+
+bool CEGLNativeTypeOdroid::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+    return false;
+}
+
+bool CEGLNativeTypeOdroid::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+    RESOLUTION_INFO res;
+    int iRet = GetNativeResolution(&res);
+    if (iRet && res.iWidth > 1 && res.iHeight > 1)
+    {
+        resolutions.push_back(res);
+        return true;
+    }
+    return false;
+}
+
+bool CEGLNativeTypeOdroid::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+    GetNativeResolution(res);
+    return true;
+}
+
+bool CEGLNativeTypeOdroid::ShowWindow(bool show)
+{
+    Display *xDisplay;
+    Window nativeWindow;
+    xDisplay = (Display *) m_nativeDisplay;
+    nativeWindow = (Window) m_nativeWindow;
+    if (show) {
+      XMapWindow(xDisplay, nativeWindow);
+    } else {
+      XUnmapWindow(xDisplay, nativeWindow);
+    }
+    XSync(xDisplay, False);
+    return false;
+}
diff --git a/xbmc/windowing/egl/EGLNativeTypeOdroid.h b/xbmc/windowing/egl/EGLNativeTypeOdroid.h
new file mode 100644
index 0000000..790f7ed
--- /dev/null
+++ b/xbmc/windowing/egl/EGLNativeTypeOdroid.h
@@ -0,0 +1,49 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+#include <list>
+
+class CEGLNativeTypeOdroid : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeOdroid();
+  virtual ~CEGLNativeTypeOdroid();
+  virtual std::string GetNativeName() const { return "odroid"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+  virtual bool  ShowWindow(bool show);
+};
diff --git a/xbmc/windowing/egl/EGLWrapper.cpp b/xbmc/windowing/egl/EGLWrapper.cpp
index a5442e1..eb7c254 100644
--- a/xbmc/windowing/egl/EGLWrapper.cpp
+++ b/xbmc/windowing/egl/EGLWrapper.cpp
@@ -26,6 +26,7 @@
 #include "EGLNativeTypeAndroid.h"
 #include "EGLNativeTypeAmlogic.h"
 #include "EGLNativeTypeRaspberryPI.h"
+#include "EGLNativeTypeOdroid.h"
 #include "EGLWrapper.h"
 
 #define CheckError() m_result = eglGetError(); if(m_result != EGL_SUCCESS) CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, m_result);
@@ -84,6 +85,20 @@ bool CEGLWrapper::Initialize(const std::string &implementation)
     }
   }
 
+  if (!ret)
+  {
+    delete nativeGuess;
+    nativeGuess = new CEGLNativeTypeOdroid;
+    if (nativeGuess->CheckCompatibility())
+    {
+      if(implementation == nativeGuess->GetNativeName() || implementation == "auto")
+      {
+        m_nativeTypes = nativeGuess;
+        ret = true;
+      }
+    }
+  }
+
   if (ret && m_nativeTypes)
     m_nativeTypes->Initialize();
 
diff --git a/xbmc/windowing/egl/Makefile b/xbmc/windowing/egl/Makefile
index 241220a..e0b13f6 100644
--- a/xbmc/windowing/egl/Makefile
+++ b/xbmc/windowing/egl/Makefile
@@ -4,6 +4,7 @@ SRCS = WinSystemEGL.cpp
 SRCS+= EGLNativeTypeAmlogic.cpp
 SRCS+= EGLNativeTypeAndroid.cpp
 SRCS+= EGLNativeTypeRaspberryPI.cpp
+SRCS+= EGLNativeTypeOdroid.cpp
 SRCS+= EGLWrapper.cpp
 
 LIB = windowing_egl.a
